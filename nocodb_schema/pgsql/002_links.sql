-- Generated by airtable_export_to_postgres_sql.js
-- 2026-02-19T16:55:32.887Z
SET client_min_messages TO WARNING;
BEGIN;

-- M2M_LINK: Airtable multi-link field strains.lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_strains_lots_lots" (
  "strains_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_strains_lots_lots_strains_id_idx" ON "public"."_m2m_strains_lots_lots"("strains_id");
CREATE INDEX IF NOT EXISTS "_m2m_strains_lots_lots_lots_id_idx" ON "public"."_m2m_strains_lots_lots"("lots_id");
ALTER TABLE "public"."_m2m_strains_lots_lots"
  ADD CONSTRAINT "_m2m_strains_lots_lots_strains_id_fk" FOREIGN KEY ("strains_id") REFERENCES "public"."strains"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_strains_lots_lots"
  ADD CONSTRAINT "_m2m_strains_lots_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field strains.ecommerce -> ecommerce

CREATE TABLE IF NOT EXISTS "public"."_m2m_strains_ecommerce_ecommerce" (
  "strains_id" bigint NOT NULL,
  "ecommerce_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_strains_ecommerce_ecommerce_strains_id_idx" ON "public"."_m2m_strains_ecommerce_ecommerce"("strains_id");
CREATE INDEX IF NOT EXISTS "_m2m_strains_ecommerce_ecommerce_ecommerce_id_idx" ON "public"."_m2m_strains_ecommerce_ecommerce"("ecommerce_id");
ALTER TABLE "public"."_m2m_strains_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_strains_ecommerce_ecommerce_strains_id_fk" FOREIGN KEY ("strains_id") REFERENCES "public"."strains"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_strains_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_strains_ecommerce_ecommerce_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field strains.products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_strains_products_products" (
  "strains_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_strains_products_products_strains_id_idx" ON "public"."_m2m_strains_products_products"("strains_id");
CREATE INDEX IF NOT EXISTS "_m2m_strains_products_products_products_id_idx" ON "public"."_m2m_strains_products_products"("products_id");
ALTER TABLE "public"."_m2m_strains_products_products"
  ADD CONSTRAINT "_m2m_strains_products_products_strains_id_fk" FOREIGN KEY ("strains_id") REFERENCES "public"."strains"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_strains_products_products"
  ADD CONSTRAINT "_m2m_strains_products_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field recipes.lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_recipes_lots_lots" (
  "recipes_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_recipes_lots_lots_recipes_id_idx" ON "public"."_m2m_recipes_lots_lots"("recipes_id");
CREATE INDEX IF NOT EXISTS "_m2m_recipes_lots_lots_lots_id_idx" ON "public"."_m2m_recipes_lots_lots"("lots_id");
ALTER TABLE "public"."_m2m_recipes_lots_lots"
  ADD CONSTRAINT "_m2m_recipes_lots_lots_recipes_id_fk" FOREIGN KEY ("recipes_id") REFERENCES "public"."recipes"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_recipes_lots_lots"
  ADD CONSTRAINT "_m2m_recipes_lots_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field recipes.sterilization_runs -> sterilization_runs

CREATE TABLE IF NOT EXISTS "public"."_m2m_recipes_sterilization_runs_sterilization_runs" (
  "recipes_id" bigint NOT NULL,
  "sterilization_runs_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_recipes_sterilization_runs_sterilization_runs_r_9d35cc150c" ON "public"."_m2m_recipes_sterilization_runs_sterilization_runs"("recipes_id");
CREATE INDEX IF NOT EXISTS "_m2m_recipes_sterilization_runs_sterilization_runs_s_0b7f19d177" ON "public"."_m2m_recipes_sterilization_runs_sterilization_runs"("sterilization_runs_id");
ALTER TABLE "public"."_m2m_recipes_sterilization_runs_sterilization_runs"
  ADD CONSTRAINT "_m2m_recipes_sterilization_runs_sterilization_runs_r_22467f5267" FOREIGN KEY ("recipes_id") REFERENCES "public"."recipes"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_recipes_sterilization_runs_sterilization_runs"
  ADD CONSTRAINT "_m2m_recipes_sterilization_runs_sterilization_runs_s_390c397b0b" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK products.item_id -> items.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_items_item_id" (
  "products_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_items_item_id_products_id_idx" ON "public"."_m2m_products_items_item_id"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_items_item_id_items_id_idx" ON "public"."_m2m_products_items_item_id"("items_id");
ALTER TABLE "public"."_m2m_products_items_item_id"
  ADD CONSTRAINT "_m2m_products_items_item_id_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_items_item_id"
  ADD CONSTRAINT "_m2m_products_items_item_id_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_products_items_item_id_products_id_uniq" ON "public"."_m2m_products_items_item_id"("products_id");

CREATE OR REPLACE FUNCTION "public"."sync_products_item_id_to__m2m_products_items_item_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_products_items_item_id"
     WHERE "products_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_products_items_item_id"
   WHERE "products_id" = NEW."nocopk";

  IF NEW."item_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_products_items_item_id"("products_id", "items_id")
    VALUES (NEW."nocopk", NEW."item_id")
    ON CONFLICT ("products_id") DO UPDATE SET "items_id" = EXCLUDED."items_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_products_item_id_to__m2m_products_items_item_id" ON "public"."products";
CREATE TRIGGER "trg_products_item_id_to__m2m_products_items_item_id"
AFTER INSERT OR UPDATE OF "item_id" OR DELETE ON "public"."products"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_products_item_id_to__m2m_products_items_item_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK products.package_item_id -> items.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_items_package_item" (
  "products_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_items_package_item_products_id_idx" ON "public"."_m2m_products_items_package_item"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_items_package_item_items_id_idx" ON "public"."_m2m_products_items_package_item"("items_id");
ALTER TABLE "public"."_m2m_products_items_package_item"
  ADD CONSTRAINT "_m2m_products_items_package_item_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_items_package_item"
  ADD CONSTRAINT "_m2m_products_items_package_item_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_products_items_package_item_products_id_uniq" ON "public"."_m2m_products_items_package_item"("products_id");

CREATE OR REPLACE FUNCTION "public"."sync_products_package_item_id_to__m2m_products_items_2cea7b428a"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_products_items_package_item"
     WHERE "products_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_products_items_package_item"
   WHERE "products_id" = NEW."nocopk";

  IF NEW."package_item_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_products_items_package_item"("products_id", "items_id")
    VALUES (NEW."nocopk", NEW."package_item_id")
    ON CONFLICT ("products_id") DO UPDATE SET "items_id" = EXCLUDED."items_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_products_package_item_id_to__m2m_products_items__b418c6ca27" ON "public"."products";
CREATE TRIGGER "trg_products_package_item_id_to__m2m_products_items__b418c6ca27"
AFTER INSERT OR UPDATE OF "package_item_id" OR DELETE ON "public"."products"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_products_package_item_id_to__m2m_products_items_2cea7b428a"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK products.storage_location_id -> locations.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_locations_storage_location" (
  "products_id" bigint NOT NULL,
  "locations_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_locations_storage_location_products_id_idx" ON "public"."_m2m_products_locations_storage_location"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_locations_storage_location_locations_id_idx" ON "public"."_m2m_products_locations_storage_location"("locations_id");
ALTER TABLE "public"."_m2m_products_locations_storage_location"
  ADD CONSTRAINT "_m2m_products_locations_storage_location_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_locations_storage_location"
  ADD CONSTRAINT "_m2m_products_locations_storage_location_locations_id_fk" FOREIGN KEY ("locations_id") REFERENCES "public"."locations"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_products_locations_storage_location_products_id_uniq" ON "public"."_m2m_products_locations_storage_location"("products_id");

CREATE OR REPLACE FUNCTION "public"."sync_products_storage_location_id_to__m2m_products_l_36358095e7"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_products_locations_storage_location"
     WHERE "products_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_products_locations_storage_location"
   WHERE "products_id" = NEW."nocopk";

  IF NEW."storage_location_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_products_locations_storage_location"("products_id", "locations_id")
    VALUES (NEW."nocopk", NEW."storage_location_id")
    ON CONFLICT ("products_id") DO UPDATE SET "locations_id" = EXCLUDED."locations_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_products_storage_location_id_to__m2m_products_lo_7fa626eed2" ON "public"."products";
CREATE TRIGGER "trg_products_storage_location_id_to__m2m_products_lo_7fa626eed2"
AFTER INSERT OR UPDATE OF "storage_location_id" OR DELETE ON "public"."products"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_products_storage_location_id_to__m2m_products_l_36358095e7"();

-- M2M_LINK: Airtable multi-link field products.merge_tray_products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_products_merge_tray_products" (
  "products_id" bigint NOT NULL,
  "products1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_products_merge_tray_products_products_id_idx" ON "public"."_m2m_products_products_merge_tray_products"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_products_merge_tray_products_products1_id_idx" ON "public"."_m2m_products_products_merge_tray_products"("products1_id");
ALTER TABLE "public"."_m2m_products_products_merge_tray_products"
  ADD CONSTRAINT "_m2m_products_products_merge_tray_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_products_merge_tray_products"
  ADD CONSTRAINT "_m2m_products_products_merge_tray_products_products1_id_fk" FOREIGN KEY ("products1_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field products.origin_lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_lots_origin_lots" (
  "products_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_lots_origin_lots_products_id_idx" ON "public"."_m2m_products_lots_origin_lots"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_lots_origin_lots_lots_id_idx" ON "public"."_m2m_products_lots_origin_lots"("lots_id");
ALTER TABLE "public"."_m2m_products_lots_origin_lots"
  ADD CONSTRAINT "_m2m_products_lots_origin_lots_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_lots_origin_lots"
  ADD CONSTRAINT "_m2m_products_lots_origin_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK products.strain_id -> strains.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_strains_strain_id" (
  "products_id" bigint NOT NULL,
  "strains_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_strains_strain_id_products_id_idx" ON "public"."_m2m_products_strains_strain_id"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_strains_strain_id_strains_id_idx" ON "public"."_m2m_products_strains_strain_id"("strains_id");
ALTER TABLE "public"."_m2m_products_strains_strain_id"
  ADD CONSTRAINT "_m2m_products_strains_strain_id_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_strains_strain_id"
  ADD CONSTRAINT "_m2m_products_strains_strain_id_strains_id_fk" FOREIGN KEY ("strains_id") REFERENCES "public"."strains"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_products_strains_strain_id_products_id_uniq" ON "public"."_m2m_products_strains_strain_id"("products_id");

CREATE OR REPLACE FUNCTION "public"."sync_products_strain_id_to__m2m_products_strains_strain_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_products_strains_strain_id"
     WHERE "products_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_products_strains_strain_id"
   WHERE "products_id" = NEW."nocopk";

  IF NEW."strain_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_products_strains_strain_id"("products_id", "strains_id")
    VALUES (NEW."nocopk", NEW."strain_id")
    ON CONFLICT ("products_id") DO UPDATE SET "strains_id" = EXCLUDED."strains_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_products_strain_id_to__m2m_products_strains_strain_id" ON "public"."products";
CREATE TRIGGER "trg_products_strain_id_to__m2m_products_strains_strain_id"
AFTER INSERT OR UPDATE OF "strain_id" OR DELETE ON "public"."products"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_products_strain_id_to__m2m_products_strains_strain_id"();

-- M2M_LINK: Airtable multi-link field products.print_queue -> print_queue

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_print_queue_print_queue" (
  "products_id" bigint NOT NULL,
  "print_queue_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_print_queue_print_queue_products_id_idx" ON "public"."_m2m_products_print_queue_print_queue"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_print_queue_print_queue_print_queue_id_idx" ON "public"."_m2m_products_print_queue_print_queue"("print_queue_id");
ALTER TABLE "public"."_m2m_products_print_queue_print_queue"
  ADD CONSTRAINT "_m2m_products_print_queue_print_queue_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_print_queue_print_queue"
  ADD CONSTRAINT "_m2m_products_print_queue_print_queue_print_queue_id_fk" FOREIGN KEY ("print_queue_id") REFERENCES "public"."print_queue"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field products.ecommerce -> ecommerce

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_ecommerce_ecommerce" (
  "products_id" bigint NOT NULL,
  "ecommerce_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_ecommerce_ecommerce_products_id_idx" ON "public"."_m2m_products_ecommerce_ecommerce"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_ecommerce_ecommerce_ecommerce_id_idx" ON "public"."_m2m_products_ecommerce_ecommerce"("ecommerce_id");
ALTER TABLE "public"."_m2m_products_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_products_ecommerce_ecommerce_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_products_ecommerce_ecommerce_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field products.ecommerce_orders -> ecommerce_orders

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_ecommerce_orders_ecommerce_orders" (
  "products_id" bigint NOT NULL,
  "ecommerce_orders_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_ecommerce_orders_ecommerce_orders_products_id_idx" ON "public"."_m2m_products_ecommerce_orders_ecommerce_orders"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_ecommerce_orders_ecommerce_orders_ecom_6376bebac1" ON "public"."_m2m_products_ecommerce_orders_ecommerce_orders"("ecommerce_orders_id");
ALTER TABLE "public"."_m2m_products_ecommerce_orders_ecommerce_orders"
  ADD CONSTRAINT "_m2m_products_ecommerce_orders_ecommerce_orders_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_ecommerce_orders_ecommerce_orders"
  ADD CONSTRAINT "_m2m_products_ecommerce_orders_ecommerce_orders_ecom_eb021abb51" FOREIGN KEY ("ecommerce_orders_id") REFERENCES "public"."ecommerce_orders"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field products.events -> events

CREATE TABLE IF NOT EXISTS "public"."_m2m_products_events_events" (
  "products_id" bigint NOT NULL,
  "events_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_products_events_events_products_id_idx" ON "public"."_m2m_products_events_events"("products_id");
CREATE INDEX IF NOT EXISTS "_m2m_products_events_events_events_id_idx" ON "public"."_m2m_products_events_events"("events_id");
ALTER TABLE "public"."_m2m_products_events_events"
  ADD CONSTRAINT "_m2m_products_events_events_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_products_events_events"
  ADD CONSTRAINT "_m2m_products_events_events_events_id_fk" FOREIGN KEY ("events_id") REFERENCES "public"."events"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.item_id -> items.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_items_item_id" (
  "lots_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_items_item_id_lots_id_idx" ON "public"."_m2m_lots_items_item_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_items_item_id_items_id_idx" ON "public"."_m2m_lots_items_item_id"("items_id");
ALTER TABLE "public"."_m2m_lots_items_item_id"
  ADD CONSTRAINT "_m2m_lots_items_item_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_items_item_id"
  ADD CONSTRAINT "_m2m_lots_items_item_id_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_items_item_id_lots_id_uniq" ON "public"."_m2m_lots_items_item_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_item_id_to__m2m_lots_items_item_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_items_item_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_items_item_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."item_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_items_item_id"("lots_id", "items_id")
    VALUES (NEW."nocopk", NEW."item_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "items_id" = EXCLUDED."items_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_item_id_to__m2m_lots_items_item_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_item_id_to__m2m_lots_items_item_id"
AFTER INSERT OR UPDATE OF "item_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_item_id_to__m2m_lots_items_item_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.recipe_id -> recipes.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_recipes_recipe_id" (
  "lots_id" bigint NOT NULL,
  "recipes_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_recipes_recipe_id_lots_id_idx" ON "public"."_m2m_lots_recipes_recipe_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_recipes_recipe_id_recipes_id_idx" ON "public"."_m2m_lots_recipes_recipe_id"("recipes_id");
ALTER TABLE "public"."_m2m_lots_recipes_recipe_id"
  ADD CONSTRAINT "_m2m_lots_recipes_recipe_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_recipes_recipe_id"
  ADD CONSTRAINT "_m2m_lots_recipes_recipe_id_recipes_id_fk" FOREIGN KEY ("recipes_id") REFERENCES "public"."recipes"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_recipes_recipe_id_lots_id_uniq" ON "public"."_m2m_lots_recipes_recipe_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_recipe_id_to__m2m_lots_recipes_recipe_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_recipes_recipe_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_recipes_recipe_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."recipe_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_recipes_recipe_id"("lots_id", "recipes_id")
    VALUES (NEW."nocopk", NEW."recipe_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "recipes_id" = EXCLUDED."recipes_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_recipe_id_to__m2m_lots_recipes_recipe_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_recipe_id_to__m2m_lots_recipes_recipe_id"
AFTER INSERT OR UPDATE OF "recipe_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_recipe_id_to__m2m_lots_recipes_recipe_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.strain_id -> strains.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_strains_strain_id" (
  "lots_id" bigint NOT NULL,
  "strains_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_strains_strain_id_lots_id_idx" ON "public"."_m2m_lots_strains_strain_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_strains_strain_id_strains_id_idx" ON "public"."_m2m_lots_strains_strain_id"("strains_id");
ALTER TABLE "public"."_m2m_lots_strains_strain_id"
  ADD CONSTRAINT "_m2m_lots_strains_strain_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_strains_strain_id"
  ADD CONSTRAINT "_m2m_lots_strains_strain_id_strains_id_fk" FOREIGN KEY ("strains_id") REFERENCES "public"."strains"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_strains_strain_id_lots_id_uniq" ON "public"."_m2m_lots_strains_strain_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_strain_id_to__m2m_lots_strains_strain_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_strains_strain_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_strains_strain_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."strain_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_strains_strain_id"("lots_id", "strains_id")
    VALUES (NEW."nocopk", NEW."strain_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "strains_id" = EXCLUDED."strains_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_strain_id_to__m2m_lots_strains_strain_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_strain_id_to__m2m_lots_strains_strain_id"
AFTER INSERT OR UPDATE OF "strain_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_strain_id_to__m2m_lots_strains_strain_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.steri_run_id -> sterilization_runs.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_sterilization_runs_steri_run_id" (
  "lots_id" bigint NOT NULL,
  "sterilization_runs_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_sterilization_runs_steri_run_id_lots_id_idx" ON "public"."_m2m_lots_sterilization_runs_steri_run_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_sterilization_runs_steri_run_id_sterilizat_61c9dd1b9b" ON "public"."_m2m_lots_sterilization_runs_steri_run_id"("sterilization_runs_id");
ALTER TABLE "public"."_m2m_lots_sterilization_runs_steri_run_id"
  ADD CONSTRAINT "_m2m_lots_sterilization_runs_steri_run_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_sterilization_runs_steri_run_id"
  ADD CONSTRAINT "_m2m_lots_sterilization_runs_steri_run_id_sterilizat_551132c151" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_sterilization_runs_steri_run_id_lots_id_uniq" ON "public"."_m2m_lots_sterilization_runs_steri_run_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_steri_run_id_to__m2m_lots_sterilization_ru_a80384c4f9"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_sterilization_runs_steri_run_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_sterilization_runs_steri_run_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."steri_run_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_sterilization_runs_steri_run_id"("lots_id", "sterilization_runs_id")
    VALUES (NEW."nocopk", NEW."steri_run_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "sterilization_runs_id" = EXCLUDED."sterilization_runs_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_steri_run_id_to__m2m_lots_sterilization_run_68f667ec48" ON "public"."lots";
CREATE TRIGGER "trg_lots_steri_run_id_to__m2m_lots_sterilization_run_68f667ec48"
AFTER INSERT OR UPDATE OF "steri_run_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_steri_run_id_to__m2m_lots_sterilization_ru_a80384c4f9"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.location_id -> locations.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_locations_location_id" (
  "lots_id" bigint NOT NULL,
  "locations_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_locations_location_id_lots_id_idx" ON "public"."_m2m_lots_locations_location_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_locations_location_id_locations_id_idx" ON "public"."_m2m_lots_locations_location_id"("locations_id");
ALTER TABLE "public"."_m2m_lots_locations_location_id"
  ADD CONSTRAINT "_m2m_lots_locations_location_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_locations_location_id"
  ADD CONSTRAINT "_m2m_lots_locations_location_id_locations_id_fk" FOREIGN KEY ("locations_id") REFERENCES "public"."locations"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_locations_location_id_lots_id_uniq" ON "public"."_m2m_lots_locations_location_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_location_id_to__m2m_lots_locations_location_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_locations_location_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_locations_location_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."location_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_locations_location_id"("lots_id", "locations_id")
    VALUES (NEW."nocopk", NEW."location_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "locations_id" = EXCLUDED."locations_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_location_id_to__m2m_lots_locations_location_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_location_id_to__m2m_lots_locations_location_id"
AFTER INSERT OR UPDATE OF "location_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_location_id_to__m2m_lots_locations_location_id"();

-- M2M_LINK: Airtable multi-link field lots.events -> events

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_events_events" (
  "lots_id" bigint NOT NULL,
  "events_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_events_events_lots_id_idx" ON "public"."_m2m_lots_events_events"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_events_events_events_id_idx" ON "public"."_m2m_lots_events_events"("events_id");
ALTER TABLE "public"."_m2m_lots_events_events"
  ADD CONSTRAINT "_m2m_lots_events_events_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_events_events"
  ADD CONSTRAINT "_m2m_lots_events_events_events_id_fk" FOREIGN KEY ("events_id") REFERENCES "public"."events"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field lots.target_lot_ids -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_lots_target_lot_ids" (
  "lots_id" bigint NOT NULL,
  "lots1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_target_lot_ids_lots_id_idx" ON "public"."_m2m_lots_lots_target_lot_ids"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_target_lot_ids_lots1_id_idx" ON "public"."_m2m_lots_lots_target_lot_ids"("lots1_id");
ALTER TABLE "public"."_m2m_lots_lots_target_lot_ids"
  ADD CONSTRAINT "_m2m_lots_lots_target_lot_ids_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_lots_target_lot_ids"
  ADD CONSTRAINT "_m2m_lots_lots_target_lot_ids_lots1_id_fk" FOREIGN KEY ("lots1_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field lots.grain_inputs -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_lots_grain_inputs" (
  "lots_id" bigint NOT NULL,
  "lots1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_grain_inputs_lots_id_idx" ON "public"."_m2m_lots_lots_grain_inputs"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_grain_inputs_lots1_id_idx" ON "public"."_m2m_lots_lots_grain_inputs"("lots1_id");
ALTER TABLE "public"."_m2m_lots_lots_grain_inputs"
  ADD CONSTRAINT "_m2m_lots_lots_grain_inputs_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_lots_grain_inputs"
  ADD CONSTRAINT "_m2m_lots_lots_grain_inputs_lots1_id_fk" FOREIGN KEY ("lots1_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field lots.substrate_inputs -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_lots_substrate_inputs" (
  "lots_id" bigint NOT NULL,
  "lots1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_substrate_inputs_lots_id_idx" ON "public"."_m2m_lots_lots_substrate_inputs"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_substrate_inputs_lots1_id_idx" ON "public"."_m2m_lots_lots_substrate_inputs"("lots1_id");
ALTER TABLE "public"."_m2m_lots_lots_substrate_inputs"
  ADD CONSTRAINT "_m2m_lots_lots_substrate_inputs_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_lots_substrate_inputs"
  ADD CONSTRAINT "_m2m_lots_lots_substrate_inputs_lots1_id_fk" FOREIGN KEY ("lots1_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.syringe_item_id -> items.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_items_syringe_item" (
  "lots_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_items_syringe_item_lots_id_idx" ON "public"."_m2m_lots_items_syringe_item"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_items_syringe_item_items_id_idx" ON "public"."_m2m_lots_items_syringe_item"("items_id");
ALTER TABLE "public"."_m2m_lots_items_syringe_item"
  ADD CONSTRAINT "_m2m_lots_items_syringe_item_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_items_syringe_item"
  ADD CONSTRAINT "_m2m_lots_items_syringe_item_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_items_syringe_item_lots_id_uniq" ON "public"."_m2m_lots_items_syringe_item"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_syringe_item_id_to__m2m_lots_items_syringe_item"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_items_syringe_item"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_items_syringe_item"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."syringe_item_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_items_syringe_item"("lots_id", "items_id")
    VALUES (NEW."nocopk", NEW."syringe_item_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "items_id" = EXCLUDED."items_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_syringe_item_id_to__m2m_lots_items_syringe_item" ON "public"."lots";
CREATE TRIGGER "trg_lots_syringe_item_id_to__m2m_lots_items_syringe_item"
AFTER INSERT OR UPDATE OF "syringe_item_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_syringe_item_id_to__m2m_lots_items_syringe_item"();

-- M2M_LINK: Airtable multi-link field lots.harvest_item -> items

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_items_harvest_item" (
  "lots_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_items_harvest_item_lots_id_idx" ON "public"."_m2m_lots_items_harvest_item"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_items_harvest_item_items_id_idx" ON "public"."_m2m_lots_items_harvest_item"("items_id");
ALTER TABLE "public"."_m2m_lots_items_harvest_item"
  ADD CONSTRAINT "_m2m_lots_items_harvest_item_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_items_harvest_item"
  ADD CONSTRAINT "_m2m_lots_items_harvest_item_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field lots.products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_products_products" (
  "lots_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_products_products_lots_id_idx" ON "public"."_m2m_lots_products_products"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_products_products_products_id_idx" ON "public"."_m2m_lots_products_products"("products_id");
ALTER TABLE "public"."_m2m_lots_products_products"
  ADD CONSTRAINT "_m2m_lots_products_products_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_products_products"
  ADD CONSTRAINT "_m2m_lots_products_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.casing_lot_id -> lots.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_lots_casing_lot_id" (
  "lots_id" bigint NOT NULL,
  "lots1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_casing_lot_id_lots_id_idx" ON "public"."_m2m_lots_lots_casing_lot_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_casing_lot_id_lots1_id_idx" ON "public"."_m2m_lots_lots_casing_lot_id"("lots1_id");
ALTER TABLE "public"."_m2m_lots_lots_casing_lot_id"
  ADD CONSTRAINT "_m2m_lots_lots_casing_lot_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_lots_casing_lot_id"
  ADD CONSTRAINT "_m2m_lots_lots_casing_lot_id_lots1_id_fk" FOREIGN KEY ("lots1_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_lots_casing_lot_id_lots_id_uniq" ON "public"."_m2m_lots_lots_casing_lot_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_casing_lot_id_to__m2m_lots_lots_casing_lot_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_lots_casing_lot_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_lots_casing_lot_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."casing_lot_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_lots_casing_lot_id"("lots_id", "lots1_id")
    VALUES (NEW."nocopk", NEW."casing_lot_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "lots1_id" = EXCLUDED."lots1_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_casing_lot_id_to__m2m_lots_lots_casing_lot_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_casing_lot_id_to__m2m_lots_lots_casing_lot_id"
AFTER INSERT OR UPDATE OF "casing_lot_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_casing_lot_id_to__m2m_lots_lots_casing_lot_id"();

-- M2M_LINK: Airtable multi-link field lots.print_queue -> print_queue

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_print_queue_print_queue" (
  "lots_id" bigint NOT NULL,
  "print_queue_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_print_queue_print_queue_lots_id_idx" ON "public"."_m2m_lots_print_queue_print_queue"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_print_queue_print_queue_print_queue_id_idx" ON "public"."_m2m_lots_print_queue_print_queue"("print_queue_id");
ALTER TABLE "public"."_m2m_lots_print_queue_print_queue"
  ADD CONSTRAINT "_m2m_lots_print_queue_print_queue_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_print_queue_print_queue"
  ADD CONSTRAINT "_m2m_lots_print_queue_print_queue_print_queue_id_fk" FOREIGN KEY ("print_queue_id") REFERENCES "public"."print_queue"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.source_lot_id -> lots.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_lots_source_lot_id" (
  "lots_id" bigint NOT NULL,
  "lots1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_source_lot_id_lots_id_idx" ON "public"."_m2m_lots_lots_source_lot_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_source_lot_id_lots1_id_idx" ON "public"."_m2m_lots_lots_source_lot_id"("lots1_id");
ALTER TABLE "public"."_m2m_lots_lots_source_lot_id"
  ADD CONSTRAINT "_m2m_lots_lots_source_lot_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_lots_source_lot_id"
  ADD CONSTRAINT "_m2m_lots_lots_source_lot_id_lots1_id_fk" FOREIGN KEY ("lots1_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_lots_source_lot_id_lots_id_uniq" ON "public"."_m2m_lots_lots_source_lot_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_source_lot_id_to__m2m_lots_lots_source_lot_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_lots_source_lot_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_lots_source_lot_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."source_lot_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_lots_source_lot_id"("lots_id", "lots1_id")
    VALUES (NEW."nocopk", NEW."source_lot_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "lots1_id" = EXCLUDED."lots1_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_source_lot_id_to__m2m_lots_lots_source_lot_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_source_lot_id_to__m2m_lots_lots_source_lot_id"
AFTER INSERT OR UPDATE OF "source_lot_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_source_lot_id_to__m2m_lots_lots_source_lot_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK lots.parent_lot_id -> lots.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_lots_parent_lot_id" (
  "lots_id" bigint NOT NULL,
  "lots1_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_parent_lot_id_lots_id_idx" ON "public"."_m2m_lots_lots_parent_lot_id"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_lots_parent_lot_id_lots1_id_idx" ON "public"."_m2m_lots_lots_parent_lot_id"("lots1_id");
ALTER TABLE "public"."_m2m_lots_lots_parent_lot_id"
  ADD CONSTRAINT "_m2m_lots_lots_parent_lot_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_lots_parent_lot_id"
  ADD CONSTRAINT "_m2m_lots_lots_parent_lot_id_lots1_id_fk" FOREIGN KEY ("lots1_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_lots_lots_parent_lot_id_lots_id_uniq" ON "public"."_m2m_lots_lots_parent_lot_id"("lots_id");

CREATE OR REPLACE FUNCTION "public"."sync_lots_parent_lot_id_to__m2m_lots_lots_parent_lot_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_lots_lots_parent_lot_id"
     WHERE "lots_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_lots_lots_parent_lot_id"
   WHERE "lots_id" = NEW."nocopk";

  IF NEW."parent_lot_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_lots_lots_parent_lot_id"("lots_id", "lots1_id")
    VALUES (NEW."nocopk", NEW."parent_lot_id")
    ON CONFLICT ("lots_id") DO UPDATE SET "lots1_id" = EXCLUDED."lots1_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_lots_parent_lot_id_to__m2m_lots_lots_parent_lot_id" ON "public"."lots";
CREATE TRIGGER "trg_lots_parent_lot_id_to__m2m_lots_lots_parent_lot_id"
AFTER INSERT OR UPDATE OF "parent_lot_id" OR DELETE ON "public"."lots"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_lots_parent_lot_id_to__m2m_lots_lots_parent_lot_id"();

-- M2M_LINK: Airtable multi-link field lots.ecommerce -> ecommerce

CREATE TABLE IF NOT EXISTS "public"."_m2m_lots_ecommerce_ecommerce" (
  "lots_id" bigint NOT NULL,
  "ecommerce_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_lots_ecommerce_ecommerce_lots_id_idx" ON "public"."_m2m_lots_ecommerce_ecommerce"("lots_id");
CREATE INDEX IF NOT EXISTS "_m2m_lots_ecommerce_ecommerce_ecommerce_id_idx" ON "public"."_m2m_lots_ecommerce_ecommerce"("ecommerce_id");
ALTER TABLE "public"."_m2m_lots_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_lots_ecommerce_ecommerce_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_lots_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_lots_ecommerce_ecommerce_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_lots_lots" (
  "items_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_lots_lots_items_id_idx" ON "public"."_m2m_items_lots_lots"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_lots_lots_lots_id_idx" ON "public"."_m2m_items_lots_lots"("lots_id");
ALTER TABLE "public"."_m2m_items_lots_lots"
  ADD CONSTRAINT "_m2m_items_lots_lots_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_lots_lots"
  ADD CONSTRAINT "_m2m_items_lots_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.sterilization_runs -> sterilization_runs

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_sterilization_runs_sterilization_runs" (
  "items_id" bigint NOT NULL,
  "sterilization_runs_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_sterilization_runs_sterilization_runs_items_id_idx" ON "public"."_m2m_items_sterilization_runs_sterilization_runs"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_sterilization_runs_sterilization_runs_ste_9ccdd757e6" ON "public"."_m2m_items_sterilization_runs_sterilization_runs"("sterilization_runs_id");
ALTER TABLE "public"."_m2m_items_sterilization_runs_sterilization_runs"
  ADD CONSTRAINT "_m2m_items_sterilization_runs_sterilization_runs_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_sterilization_runs_sterilization_runs"
  ADD CONSTRAINT "_m2m_items_sterilization_runs_sterilization_runs_ste_a75882d208" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.lots_2 -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_lots_lots_2" (
  "items_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_lots_lots_2_items_id_idx" ON "public"."_m2m_items_lots_lots_2"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_lots_lots_2_lots_id_idx" ON "public"."_m2m_items_lots_lots_2"("lots_id");
ALTER TABLE "public"."_m2m_items_lots_lots_2"
  ADD CONSTRAINT "_m2m_items_lots_lots_2_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_lots_lots_2"
  ADD CONSTRAINT "_m2m_items_lots_lots_2_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_products_products" (
  "items_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_products_products_items_id_idx" ON "public"."_m2m_items_products_products"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_products_products_products_id_idx" ON "public"."_m2m_items_products_products"("products_id");
ALTER TABLE "public"."_m2m_items_products_products"
  ADD CONSTRAINT "_m2m_items_products_products_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_products_products"
  ADD CONSTRAINT "_m2m_items_products_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.lots_4 -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_lots_lots_4" (
  "items_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_lots_lots_4_items_id_idx" ON "public"."_m2m_items_lots_lots_4"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_lots_lots_4_lots_id_idx" ON "public"."_m2m_items_lots_lots_4"("lots_id");
ALTER TABLE "public"."_m2m_items_lots_lots_4"
  ADD CONSTRAINT "_m2m_items_lots_lots_4_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_lots_lots_4"
  ADD CONSTRAINT "_m2m_items_lots_lots_4_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.products_2 -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_products_products_2" (
  "items_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_products_products_2_items_id_idx" ON "public"."_m2m_items_products_products_2"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_products_products_2_products_id_idx" ON "public"."_m2m_items_products_products_2"("products_id");
ALTER TABLE "public"."_m2m_items_products_products_2"
  ADD CONSTRAINT "_m2m_items_products_products_2_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_products_products_2"
  ADD CONSTRAINT "_m2m_items_products_products_2_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field items.ecommerce -> ecommerce

CREATE TABLE IF NOT EXISTS "public"."_m2m_items_ecommerce_ecommerce" (
  "items_id" bigint NOT NULL,
  "ecommerce_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_items_ecommerce_ecommerce_items_id_idx" ON "public"."_m2m_items_ecommerce_ecommerce"("items_id");
CREATE INDEX IF NOT EXISTS "_m2m_items_ecommerce_ecommerce_ecommerce_id_idx" ON "public"."_m2m_items_ecommerce_ecommerce"("ecommerce_id");
ALTER TABLE "public"."_m2m_items_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_items_ecommerce_ecommerce_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_items_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_items_ecommerce_ecommerce_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK events.lot_id -> lots.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_events_lots_lot_id" (
  "events_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_events_lots_lot_id_events_id_idx" ON "public"."_m2m_events_lots_lot_id"("events_id");
CREATE INDEX IF NOT EXISTS "_m2m_events_lots_lot_id_lots_id_idx" ON "public"."_m2m_events_lots_lot_id"("lots_id");
ALTER TABLE "public"."_m2m_events_lots_lot_id"
  ADD CONSTRAINT "_m2m_events_lots_lot_id_events_id_fk" FOREIGN KEY ("events_id") REFERENCES "public"."events"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_events_lots_lot_id"
  ADD CONSTRAINT "_m2m_events_lots_lot_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_events_lots_lot_id_events_id_uniq" ON "public"."_m2m_events_lots_lot_id"("events_id");

CREATE OR REPLACE FUNCTION "public"."sync_events_lot_id_to__m2m_events_lots_lot_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_events_lots_lot_id"
     WHERE "events_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_events_lots_lot_id"
   WHERE "events_id" = NEW."nocopk";

  IF NEW."lot_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_events_lots_lot_id"("events_id", "lots_id")
    VALUES (NEW."nocopk", NEW."lot_id")
    ON CONFLICT ("events_id") DO UPDATE SET "lots_id" = EXCLUDED."lots_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_events_lot_id_to__m2m_events_lots_lot_id" ON "public"."events";
CREATE TRIGGER "trg_events_lot_id_to__m2m_events_lots_lot_id"
AFTER INSERT OR UPDATE OF "lot_id" OR DELETE ON "public"."events"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_events_lot_id_to__m2m_events_lots_lot_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK events.product_id -> products.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_events_products_product_id" (
  "events_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_events_products_product_id_events_id_idx" ON "public"."_m2m_events_products_product_id"("events_id");
CREATE INDEX IF NOT EXISTS "_m2m_events_products_product_id_products_id_idx" ON "public"."_m2m_events_products_product_id"("products_id");
ALTER TABLE "public"."_m2m_events_products_product_id"
  ADD CONSTRAINT "_m2m_events_products_product_id_events_id_fk" FOREIGN KEY ("events_id") REFERENCES "public"."events"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_events_products_product_id"
  ADD CONSTRAINT "_m2m_events_products_product_id_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_events_products_product_id_events_id_uniq" ON "public"."_m2m_events_products_product_id"("events_id");

CREATE OR REPLACE FUNCTION "public"."sync_events_product_id_to__m2m_events_products_product_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_events_products_product_id"
     WHERE "events_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_events_products_product_id"
   WHERE "events_id" = NEW."nocopk";

  IF NEW."product_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_events_products_product_id"("events_id", "products_id")
    VALUES (NEW."nocopk", NEW."product_id")
    ON CONFLICT ("events_id") DO UPDATE SET "products_id" = EXCLUDED."products_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_events_product_id_to__m2m_events_products_product_id" ON "public"."events";
CREATE TRIGGER "trg_events_product_id_to__m2m_events_products_product_id"
AFTER INSERT OR UPDATE OF "product_id" OR DELETE ON "public"."events"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_events_product_id_to__m2m_events_products_product_id"();

-- M2M_LINK: Airtable multi-link field locations.lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_locations_lots_lots" (
  "locations_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_locations_lots_lots_locations_id_idx" ON "public"."_m2m_locations_lots_lots"("locations_id");
CREATE INDEX IF NOT EXISTS "_m2m_locations_lots_lots_lots_id_idx" ON "public"."_m2m_locations_lots_lots"("lots_id");
ALTER TABLE "public"."_m2m_locations_lots_lots"
  ADD CONSTRAINT "_m2m_locations_lots_lots_locations_id_fk" FOREIGN KEY ("locations_id") REFERENCES "public"."locations"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_locations_lots_lots"
  ADD CONSTRAINT "_m2m_locations_lots_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field locations.products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_locations_products_products" (
  "locations_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_locations_products_products_locations_id_idx" ON "public"."_m2m_locations_products_products"("locations_id");
CREATE INDEX IF NOT EXISTS "_m2m_locations_products_products_products_id_idx" ON "public"."_m2m_locations_products_products"("products_id");
ALTER TABLE "public"."_m2m_locations_products_products"
  ADD CONSTRAINT "_m2m_locations_products_products_locations_id_fk" FOREIGN KEY ("locations_id") REFERENCES "public"."locations"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_locations_products_products"
  ADD CONSTRAINT "_m2m_locations_products_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK sterilization_runs.planned_item_id -> items.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_sterilization_runs_items_planned_item" (
  "sterilization_runs_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_items_planned_item_steriliza_2afca7db4e" ON "public"."_m2m_sterilization_runs_items_planned_item"("sterilization_runs_id");
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_items_planned_item_items_id_idx" ON "public"."_m2m_sterilization_runs_items_planned_item"("items_id");
ALTER TABLE "public"."_m2m_sterilization_runs_items_planned_item"
  ADD CONSTRAINT "_m2m_sterilization_runs_items_planned_item_steriliza_9e817300a5" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_sterilization_runs_items_planned_item"
  ADD CONSTRAINT "_m2m_sterilization_runs_items_planned_item_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_sterilization_runs_items_planned_item_steriliza_870006efbd" ON "public"."_m2m_sterilization_runs_items_planned_item"("sterilization_runs_id");

CREATE OR REPLACE FUNCTION "public"."sync_sterilization_runs_planned_item_id_to__m2m_ster_09d9f7cb26"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_sterilization_runs_items_planned_item"
     WHERE "sterilization_runs_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_sterilization_runs_items_planned_item"
   WHERE "sterilization_runs_id" = NEW."nocopk";

  IF NEW."planned_item_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_sterilization_runs_items_planned_item"("sterilization_runs_id", "items_id")
    VALUES (NEW."nocopk", NEW."planned_item_id")
    ON CONFLICT ("sterilization_runs_id") DO UPDATE SET "items_id" = EXCLUDED."items_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_sterilization_runs_planned_item_id_to__m2m_steri_baadd9f94c" ON "public"."sterilization_runs";
CREATE TRIGGER "trg_sterilization_runs_planned_item_id_to__m2m_steri_baadd9f94c"
AFTER INSERT OR UPDATE OF "planned_item_id" OR DELETE ON "public"."sterilization_runs"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_sterilization_runs_planned_item_id_to__m2m_ster_09d9f7cb26"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK sterilization_runs.planned_recipe_id -> recipes.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_sterilization_runs_recipes_planned_recipe" (
  "sterilization_runs_id" bigint NOT NULL,
  "recipes_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_recipes_planned_recipe_steri_45fc593a7e" ON "public"."_m2m_sterilization_runs_recipes_planned_recipe"("sterilization_runs_id");
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_recipes_planned_recipe_recipes_id_idx" ON "public"."_m2m_sterilization_runs_recipes_planned_recipe"("recipes_id");
ALTER TABLE "public"."_m2m_sterilization_runs_recipes_planned_recipe"
  ADD CONSTRAINT "_m2m_sterilization_runs_recipes_planned_recipe_steri_2ac55d3f2b" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_sterilization_runs_recipes_planned_recipe"
  ADD CONSTRAINT "_m2m_sterilization_runs_recipes_planned_recipe_recipes_id_fk" FOREIGN KEY ("recipes_id") REFERENCES "public"."recipes"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_sterilization_runs_recipes_planned_recipe_steri_2cd8d254c8" ON "public"."_m2m_sterilization_runs_recipes_planned_recipe"("sterilization_runs_id");

CREATE OR REPLACE FUNCTION "public"."sync_sterilization_runs_planned_recipe_id_to__m2m_st_429e59e812"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_sterilization_runs_recipes_planned_recipe"
     WHERE "sterilization_runs_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_sterilization_runs_recipes_planned_recipe"
   WHERE "sterilization_runs_id" = NEW."nocopk";

  IF NEW."planned_recipe_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_sterilization_runs_recipes_planned_recipe"("sterilization_runs_id", "recipes_id")
    VALUES (NEW."nocopk", NEW."planned_recipe_id")
    ON CONFLICT ("sterilization_runs_id") DO UPDATE SET "recipes_id" = EXCLUDED."recipes_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_sterilization_runs_planned_recipe_id_to__m2m_ste_d1be47cc34" ON "public"."sterilization_runs";
CREATE TRIGGER "trg_sterilization_runs_planned_recipe_id_to__m2m_ste_d1be47cc34"
AFTER INSERT OR UPDATE OF "planned_recipe_id" OR DELETE ON "public"."sterilization_runs"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_sterilization_runs_planned_recipe_id_to__m2m_st_429e59e812"();

-- M2M_LINK: Airtable multi-link field sterilization_runs.lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_sterilization_runs_lots_lots" (
  "sterilization_runs_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_lots_lots_sterilization_runs_id_idx" ON "public"."_m2m_sterilization_runs_lots_lots"("sterilization_runs_id");
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_lots_lots_lots_id_idx" ON "public"."_m2m_sterilization_runs_lots_lots"("lots_id");
ALTER TABLE "public"."_m2m_sterilization_runs_lots_lots"
  ADD CONSTRAINT "_m2m_sterilization_runs_lots_lots_sterilization_runs_id_fk" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_sterilization_runs_lots_lots"
  ADD CONSTRAINT "_m2m_sterilization_runs_lots_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field sterilization_runs.print_queue -> print_queue

CREATE TABLE IF NOT EXISTS "public"."_m2m_sterilization_runs_print_queue_print_queue" (
  "sterilization_runs_id" bigint NOT NULL,
  "print_queue_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_print_queue_print_queue_ster_43b740d1b1" ON "public"."_m2m_sterilization_runs_print_queue_print_queue"("sterilization_runs_id");
CREATE INDEX IF NOT EXISTS "_m2m_sterilization_runs_print_queue_print_queue_prin_a5d745200d" ON "public"."_m2m_sterilization_runs_print_queue_print_queue"("print_queue_id");
ALTER TABLE "public"."_m2m_sterilization_runs_print_queue_print_queue"
  ADD CONSTRAINT "_m2m_sterilization_runs_print_queue_print_queue_ster_1518bee7d0" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_sterilization_runs_print_queue_print_queue"
  ADD CONSTRAINT "_m2m_sterilization_runs_print_queue_print_queue_prin_140f8024f4" FOREIGN KEY ("print_queue_id") REFERENCES "public"."print_queue"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK print_queue.lot_id -> lots.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_print_queue_lots_lot_id" (
  "print_queue_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_print_queue_lots_lot_id_print_queue_id_idx" ON "public"."_m2m_print_queue_lots_lot_id"("print_queue_id");
CREATE INDEX IF NOT EXISTS "_m2m_print_queue_lots_lot_id_lots_id_idx" ON "public"."_m2m_print_queue_lots_lot_id"("lots_id");
ALTER TABLE "public"."_m2m_print_queue_lots_lot_id"
  ADD CONSTRAINT "_m2m_print_queue_lots_lot_id_print_queue_id_fk" FOREIGN KEY ("print_queue_id") REFERENCES "public"."print_queue"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_print_queue_lots_lot_id"
  ADD CONSTRAINT "_m2m_print_queue_lots_lot_id_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_print_queue_lots_lot_id_print_queue_id_uniq" ON "public"."_m2m_print_queue_lots_lot_id"("print_queue_id");

CREATE OR REPLACE FUNCTION "public"."sync_print_queue_lot_id_to__m2m_print_queue_lots_lot_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_print_queue_lots_lot_id"
     WHERE "print_queue_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_print_queue_lots_lot_id"
   WHERE "print_queue_id" = NEW."nocopk";

  IF NEW."lot_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_print_queue_lots_lot_id"("print_queue_id", "lots_id")
    VALUES (NEW."nocopk", NEW."lot_id")
    ON CONFLICT ("print_queue_id") DO UPDATE SET "lots_id" = EXCLUDED."lots_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_print_queue_lot_id_to__m2m_print_queue_lots_lot_id" ON "public"."print_queue";
CREATE TRIGGER "trg_print_queue_lot_id_to__m2m_print_queue_lots_lot_id"
AFTER INSERT OR UPDATE OF "lot_id" OR DELETE ON "public"."print_queue"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_print_queue_lot_id_to__m2m_print_queue_lots_lot_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK print_queue.product_id -> products.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_print_queue_products_product_id" (
  "print_queue_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_print_queue_products_product_id_print_queue_id_idx" ON "public"."_m2m_print_queue_products_product_id"("print_queue_id");
CREATE INDEX IF NOT EXISTS "_m2m_print_queue_products_product_id_products_id_idx" ON "public"."_m2m_print_queue_products_product_id"("products_id");
ALTER TABLE "public"."_m2m_print_queue_products_product_id"
  ADD CONSTRAINT "_m2m_print_queue_products_product_id_print_queue_id_fk" FOREIGN KEY ("print_queue_id") REFERENCES "public"."print_queue"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_print_queue_products_product_id"
  ADD CONSTRAINT "_m2m_print_queue_products_product_id_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_print_queue_products_product_id_print_queue_id_uniq" ON "public"."_m2m_print_queue_products_product_id"("print_queue_id");

CREATE OR REPLACE FUNCTION "public"."sync_print_queue_product_id_to__m2m_print_queue_prod_634938edc5"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_print_queue_products_product_id"
     WHERE "print_queue_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_print_queue_products_product_id"
   WHERE "print_queue_id" = NEW."nocopk";

  IF NEW."product_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_print_queue_products_product_id"("print_queue_id", "products_id")
    VALUES (NEW."nocopk", NEW."product_id")
    ON CONFLICT ("print_queue_id") DO UPDATE SET "products_id" = EXCLUDED."products_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_print_queue_product_id_to__m2m_print_queue_produ_f94ae3d825" ON "public"."print_queue";
CREATE TRIGGER "trg_print_queue_product_id_to__m2m_print_queue_produ_f94ae3d825"
AFTER INSERT OR UPDATE OF "product_id" OR DELETE ON "public"."print_queue"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_print_queue_product_id_to__m2m_print_queue_prod_634938edc5"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK print_queue.run_id -> sterilization_runs.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_print_queue_sterilization_runs_run_id" (
  "print_queue_id" bigint NOT NULL,
  "sterilization_runs_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_print_queue_sterilization_runs_run_id_print_queue_id_idx" ON "public"."_m2m_print_queue_sterilization_runs_run_id"("print_queue_id");
CREATE INDEX IF NOT EXISTS "_m2m_print_queue_sterilization_runs_run_id_steriliza_428ae70f79" ON "public"."_m2m_print_queue_sterilization_runs_run_id"("sterilization_runs_id");
ALTER TABLE "public"."_m2m_print_queue_sterilization_runs_run_id"
  ADD CONSTRAINT "_m2m_print_queue_sterilization_runs_run_id_print_queue_id_fk" FOREIGN KEY ("print_queue_id") REFERENCES "public"."print_queue"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_print_queue_sterilization_runs_run_id"
  ADD CONSTRAINT "_m2m_print_queue_sterilization_runs_run_id_steriliza_945895739e" FOREIGN KEY ("sterilization_runs_id") REFERENCES "public"."sterilization_runs"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_print_queue_sterilization_runs_run_id_print_queue_id_uniq" ON "public"."_m2m_print_queue_sterilization_runs_run_id"("print_queue_id");

CREATE OR REPLACE FUNCTION "public"."sync_print_queue_run_id_to__m2m_print_queue_steriliz_32179ca2a7"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_print_queue_sterilization_runs_run_id"
     WHERE "print_queue_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_print_queue_sterilization_runs_run_id"
   WHERE "print_queue_id" = NEW."nocopk";

  IF NEW."run_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_print_queue_sterilization_runs_run_id"("print_queue_id", "sterilization_runs_id")
    VALUES (NEW."nocopk", NEW."run_id")
    ON CONFLICT ("print_queue_id") DO UPDATE SET "sterilization_runs_id" = EXCLUDED."sterilization_runs_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_print_queue_run_id_to__m2m_print_queue_steriliza_79800a6b62" ON "public"."print_queue";
CREATE TRIGGER "trg_print_queue_run_id_to__m2m_print_queue_steriliza_79800a6b62"
AFTER INSERT OR UPDATE OF "run_id" OR DELETE ON "public"."print_queue"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_print_queue_run_id_to__m2m_print_queue_steriliz_32179ca2a7"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK ecommerce.item_id -> items.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_items_item_id" (
  "ecommerce_id" bigint NOT NULL,
  "items_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_items_item_id_ecommerce_id_idx" ON "public"."_m2m_ecommerce_items_item_id"("ecommerce_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_items_item_id_items_id_idx" ON "public"."_m2m_ecommerce_items_item_id"("items_id");
ALTER TABLE "public"."_m2m_ecommerce_items_item_id"
  ADD CONSTRAINT "_m2m_ecommerce_items_item_id_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_items_item_id"
  ADD CONSTRAINT "_m2m_ecommerce_items_item_id_items_id_fk" FOREIGN KEY ("items_id") REFERENCES "public"."items"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_ecommerce_items_item_id_ecommerce_id_uniq" ON "public"."_m2m_ecommerce_items_item_id"("ecommerce_id");

CREATE OR REPLACE FUNCTION "public"."sync_ecommerce_item_id_to__m2m_ecommerce_items_item_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_ecommerce_items_item_id"
     WHERE "ecommerce_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_ecommerce_items_item_id"
   WHERE "ecommerce_id" = NEW."nocopk";

  IF NEW."item_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_ecommerce_items_item_id"("ecommerce_id", "items_id")
    VALUES (NEW."nocopk", NEW."item_id")
    ON CONFLICT ("ecommerce_id") DO UPDATE SET "items_id" = EXCLUDED."items_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_ecommerce_item_id_to__m2m_ecommerce_items_item_id" ON "public"."ecommerce";
CREATE TRIGGER "trg_ecommerce_item_id_to__m2m_ecommerce_items_item_id"
AFTER INSERT OR UPDATE OF "item_id" OR DELETE ON "public"."ecommerce"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_ecommerce_item_id_to__m2m_ecommerce_items_item_id"();

-- DERIVED_M2M (prefersSingleRecordLink): canonical FK ecommerce.strain_id -> strains.nocopk; junction retained for compatibility/auditing

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_strains_strain_id" (
  "ecommerce_id" bigint NOT NULL,
  "strains_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_strains_strain_id_ecommerce_id_idx" ON "public"."_m2m_ecommerce_strains_strain_id"("ecommerce_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_strains_strain_id_strains_id_idx" ON "public"."_m2m_ecommerce_strains_strain_id"("strains_id");
ALTER TABLE "public"."_m2m_ecommerce_strains_strain_id"
  ADD CONSTRAINT "_m2m_ecommerce_strains_strain_id_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_strains_strain_id"
  ADD CONSTRAINT "_m2m_ecommerce_strains_strain_id_strains_id_fk" FOREIGN KEY ("strains_id") REFERENCES "public"."strains"("nocopk") DEFERRABLE INITIALLY DEFERRED;
CREATE UNIQUE INDEX IF NOT EXISTS "_m2m_ecommerce_strains_strain_id_ecommerce_id_uniq" ON "public"."_m2m_ecommerce_strains_strain_id"("ecommerce_id");

CREATE OR REPLACE FUNCTION "public"."sync_ecommerce_strain_id_to__m2m_ecommerce_strains_strain_id"()
RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  -- One-way sync: base FK column is canonical; junction is derived.
  IF TG_OP = 'DELETE' THEN
    DELETE FROM "public"."_m2m_ecommerce_strains_strain_id"
     WHERE "ecommerce_id" = OLD."nocopk";
    RETURN OLD;
  END IF;

  -- Keep junction in sync with the FK column
  DELETE FROM "public"."_m2m_ecommerce_strains_strain_id"
   WHERE "ecommerce_id" = NEW."nocopk";

  IF NEW."strain_id" IS NOT NULL THEN
    INSERT INTO "public"."_m2m_ecommerce_strains_strain_id"("ecommerce_id", "strains_id")
    VALUES (NEW."nocopk", NEW."strain_id")
    ON CONFLICT ("ecommerce_id") DO UPDATE SET "strains_id" = EXCLUDED."strains_id";
  END IF;

  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS "trg_ecommerce_strain_id_to__m2m_ecommerce_strains_strain_id" ON "public"."ecommerce";
CREATE TRIGGER "trg_ecommerce_strain_id_to__m2m_ecommerce_strains_strain_id"
AFTER INSERT OR UPDATE OF "strain_id" OR DELETE ON "public"."ecommerce"
FOR EACH ROW EXECUTE FUNCTION "public"."sync_ecommerce_strain_id_to__m2m_ecommerce_strains_strain_id"();

-- M2M_LINK: Airtable multi-link field ecommerce.products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_products_products" (
  "ecommerce_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_products_products_ecommerce_id_idx" ON "public"."_m2m_ecommerce_products_products"("ecommerce_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_products_products_products_id_idx" ON "public"."_m2m_ecommerce_products_products"("products_id");
ALTER TABLE "public"."_m2m_ecommerce_products_products"
  ADD CONSTRAINT "_m2m_ecommerce_products_products_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_products_products"
  ADD CONSTRAINT "_m2m_ecommerce_products_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field ecommerce.lots -> lots

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_lots_lots" (
  "ecommerce_id" bigint NOT NULL,
  "lots_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_lots_lots_ecommerce_id_idx" ON "public"."_m2m_ecommerce_lots_lots"("ecommerce_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_lots_lots_lots_id_idx" ON "public"."_m2m_ecommerce_lots_lots"("lots_id");
ALTER TABLE "public"."_m2m_ecommerce_lots_lots"
  ADD CONSTRAINT "_m2m_ecommerce_lots_lots_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_lots_lots"
  ADD CONSTRAINT "_m2m_ecommerce_lots_lots_lots_id_fk" FOREIGN KEY ("lots_id") REFERENCES "public"."lots"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field ecommerce.ecommerce_orders -> ecommerce_orders

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_ecommerce_orders_ecommerce_orders" (
  "ecommerce_id" bigint NOT NULL,
  "ecommerce_orders_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_ecommerce_orders_ecommerce_orders_eco_7637ebb745" ON "public"."_m2m_ecommerce_ecommerce_orders_ecommerce_orders"("ecommerce_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_ecommerce_orders_ecommerce_orders_eco_7a7b8aec2d" ON "public"."_m2m_ecommerce_ecommerce_orders_ecommerce_orders"("ecommerce_orders_id");
ALTER TABLE "public"."_m2m_ecommerce_ecommerce_orders_ecommerce_orders"
  ADD CONSTRAINT "_m2m_ecommerce_ecommerce_orders_ecommerce_orders_eco_4d9221e371" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_ecommerce_orders_ecommerce_orders"
  ADD CONSTRAINT "_m2m_ecommerce_ecommerce_orders_ecommerce_orders_eco_deeee65d3d" FOREIGN KEY ("ecommerce_orders_id") REFERENCES "public"."ecommerce_orders"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field ecommerce_orders.products -> products

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_orders_products_products" (
  "ecommerce_orders_id" bigint NOT NULL,
  "products_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_orders_products_products_ecommerce_orders_id_idx" ON "public"."_m2m_ecommerce_orders_products_products"("ecommerce_orders_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_orders_products_products_products_id_idx" ON "public"."_m2m_ecommerce_orders_products_products"("products_id");
ALTER TABLE "public"."_m2m_ecommerce_orders_products_products"
  ADD CONSTRAINT "_m2m_ecommerce_orders_products_products_ecommerce_orders_id_fk" FOREIGN KEY ("ecommerce_orders_id") REFERENCES "public"."ecommerce_orders"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_orders_products_products"
  ADD CONSTRAINT "_m2m_ecommerce_orders_products_products_products_id_fk" FOREIGN KEY ("products_id") REFERENCES "public"."products"("nocopk") DEFERRABLE INITIALLY DEFERRED;

-- M2M_LINK: Airtable multi-link field ecommerce_orders.ecommerce -> ecommerce

CREATE TABLE IF NOT EXISTS "public"."_m2m_ecommerce_orders_ecommerce_ecommerce" (
  "ecommerce_orders_id" bigint NOT NULL,
  "ecommerce_id" bigint NOT NULL
);
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_orders_ecommerce_ecommerce_ecommerce__7f34093e7f" ON "public"."_m2m_ecommerce_orders_ecommerce_ecommerce"("ecommerce_orders_id");
CREATE INDEX IF NOT EXISTS "_m2m_ecommerce_orders_ecommerce_ecommerce_ecommerce_id_idx" ON "public"."_m2m_ecommerce_orders_ecommerce_ecommerce"("ecommerce_id");
ALTER TABLE "public"."_m2m_ecommerce_orders_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_ecommerce_orders_ecommerce_ecommerce_ecommerce__def73ffc7c" FOREIGN KEY ("ecommerce_orders_id") REFERENCES "public"."ecommerce_orders"("nocopk") DEFERRABLE INITIALLY DEFERRED;
ALTER TABLE "public"."_m2m_ecommerce_orders_ecommerce_ecommerce"
  ADD CONSTRAINT "_m2m_ecommerce_orders_ecommerce_ecommerce_ecommerce_id_fk" FOREIGN KEY ("ecommerce_id") REFERENCES "public"."ecommerce"("nocopk") DEFERRABLE INITIALLY DEFERRED;

COMMIT;
